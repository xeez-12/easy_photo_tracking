<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Geolocation SPY</title>
  <!-- Mapbox GL JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mapbox-gl/2.15.0/mapbox-gl.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/mapbox-gl/2.15.0/mapbox-gl.css" rel="stylesheet" />
  <!-- EXIF JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    }
    body {
      width: 100%;
      height: 100vh;
      overflow: hidden;
      background-color: #121212;
      color: #fff;
    }
    #app-container {
      position: relative;
      width: 100%;
      height: 100vh;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    #streetview-container {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 20;
    }
    #streetview {
      width: 100%;
      height: 100%;
      border: none;
    }
    #info-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 300px;
      background-color: rgba(18,18,18,0.95);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 200;
    }
    #search-container {
      display: flex;
      align-items: center;
      background-color: #242424;
      border-radius: 6px;
      padding: 8px 12px;
      margin-bottom: 20px;
    }
    #search-container svg {
      margin-right: 8px;
      opacity: 0.7;
    }
    #search-input {
      background: none;
      border: none;
      color: #fff;
      outline: none;
      width: 100%;
      font-size: 14px;
    }
    #image-preview {
      width: 100%;
      aspect-ratio: 1/1;
      background-color: #242424;
      border-radius: 8px;
      margin-bottom: 15px;
      overflow: hidden;
      position: relative;
      cursor: pointer;
    }
    #image-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #upload-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: rgba(36,36,36,0.8);
      cursor: pointer;
    }
    #upload-overlay.hidden {
      display: none;
    }
    #upload-icon {
      margin-bottom: 10px;
      opacity: 0.7;
    }
    #upload-text {
      color: #fff;
      font-size: 14px;
      text-align: center;
    }
    .location-info {
      margin-bottom: 15px;
    }
    .location-label {
      color: #999;
      font-size: 12px;
      margin-bottom: 3px;
    }
    .location-value {
      color: #fff;
      font-size: 14px;
      margin-bottom: 10px;
      font-weight: 500;
    }
    #action-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 0;
    }
    .action-btn {
      flex: 1;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #444;
      background-color: #242424;
      color: #fff;
      font-size: 14px;
      cursor: pointer;
      text-align: center;
    }
    .action-btn:hover {
      background-color: #333;
    }
    .enterprise-badge {
      position: absolute;
      top: 20px;
      right: 20px;
      background-color: rgba(0,0,0,0.5);
      border-radius: 4px;
      padding: 8px 12px;
      display: flex;
      align-items: center;
      z-index: 200;
    }
    .enterprise-text {
      margin-right: 10px;
    }
    .enterprise-badge .title {
      font-size: 14px;
      font-weight: 500;
    }
    .enterprise-badge .subtitle {
      font-size: 12px;
      color: #ccc;
    }
    .badge-link {
      display: flex;
      align-items: center;
      color: white;
      text-decoration: none;
    }
    .floating-info {
      position: absolute;
      background-color: rgba(0,0,0,0.7);
      border-radius: 6px;
      padding: 10px 12px;
      z-index: 200;
      color: white;
      font-size: 13px;
    }
    #location-name {
      top: 20px;
      left: 340px;
    }
    #location-name .title {
      font-weight: 500;
      margin-bottom: 2px;
    }
    #location-name .subtitle {
      display: none;
    }
    #neighborhood-info {
      position: absolute;
      bottom: 30px;
      left: 20px;
      background-color: rgba(0,0,0,0.7);
      padding: 10px 15px;
      border-radius: 4px;
      font-size: 12px;
      color: #ccc;
      z-index: 999;
    }
    .attribution {
      display: none;
    }
    .mapboxgl-canvas {
      outline: none;
    }
    .mapboxgl-ctrl-logo {
      display: none !important;
    }
    #file-input {
      display: none;
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>
<body>
  <div id="app-container">
    <div id="map"></div>
    <div id="streetview-container">
      <iframe id="streetview"></iframe>
    </div>
    <div id="info-panel">
      <div id="search-container">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        </svg>
        <input type="text" id="search-input" placeholder="New search" />
      </div>
      <div id="image-preview">
        <img id="preview-img" src="" style="display: none;" />
        <div id="upload-overlay">
          <svg id="upload-icon" width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="17 8 12 3 7 8"></polyline>
            <line x1="12" y1="3" x2="12" y2="15"></line>
          </svg>
          <p id="upload-text">Click to upload an image</p>
        </div>
      </div>
      <div class="location-info">
        <div class="location-label">Detail</div>
        <div class="location-value" id="detail-value">unknown</div>
        <div class="location-label">Negara</div>
        <div class="location-value" id="country-value">unknown</div>
        <div class="location-label">Kota</div>
        <div class="location-value" id="city-value">unknown</div>
        <div class="location-label">Kordinator</div>
        <div class="location-value" id="coord-value">unknown</div>
      </div>
      <div id="action-buttons">
        <div class="action-btn" id="map-btn">Map</div>
        <div class="action-btn" id="share-geospy">Street View</div>
      </div>
    </div>
    <div class="enterprise-badge">
      <div class="enterprise-text">
        <div class="title">Enterprise?</div>
        <div class="subtitle">Partner with us</div>
      </div>
      <a href="#" class="badge-link">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="5" y1="12" x2="19" y2="12"></line>
          <polyline points="12 5 19 12 12 19"></polyline>
        </svg>
      </a>
    </div>
    <div class="floating-info" id="location-name">
      <div class="title">Geolocation SPY</div>
    </div>
    <div id="neighborhood-info">sweet geolocation</div>
  </div>
  <input type="file" id="file-input" accept="image/*" />
  <div id="loading-overlay" class="loading-overlay" style="display: none;">
    <div class="loading-spinner"></div>
  </div>

  <script>
    const MAPBOX_TOKEN = "pk.eyJ1IjoiYXZpb3BvcnRvbGFubyIsImEiOiJja212cmRrd2QwN3dzMnZuMXV2d25xbWsxIn0.x3y36v9arY9wmBOCZlCXUA";
    const GEMINI_API_KEY = "AIzaSyBnAFtB1TcTzpkJ1CwxgjSurhhUSVOo9HI"; // Replace with your actual Gemini API key
    mapboxgl.accessToken = MAPBOX_TOKEN;

    const map = new mapboxgl.Map({
      container: "map",
      style: "mapbox://styles/mapbox/dark-v11",
      center: [0, 0],
      zoom: 2,
      pitch: 0,
    });

    let trackingMarker = null;
    let lastMatchedCoord = { lat: 0, lng: 0 };

    const fileInput = document.getElementById("file-input");
    const previewImg = document.getElementById("preview-img");
    const uploadOverlay = document.getElementById("upload-overlay");
    const loadingOverlay = document.getElementById("loading-overlay");

    function imageToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // Advanced GEO Cell Partitioning Algorithm
    function createGeoCells(lat, lng, confidence) {
      const baseCellSize = confidence > 0.9 ? 0.002 : confidence > 0.6 ? 0.01 : 0.05; // Tighter cells
      const maxRadius = 0.1; // Limit exploration to 0.1Â° (~11 km)
      const cells = [];
      const steps = 5; // 5x5 grid for finer granularity

      for (let i = -2; i <= 2; i++) {
        for (let j = -2; j <= 2; j++) {
          const cellLat = lat + i * baseCellSize;
          const cellLng = lng + j * baseCellSize;
          // Skip cells outside max radius
          if (Math.hypot(cellLat - lat, cellLng - lng) <= maxRadius) {
            cells.push({
              center: { lat: cellLat, lng: cellLng },
              bounds: {
                minLat: cellLat - baseCellSize / 2,
                maxLat: cellLat + baseCellSize / 2,
                minLng: cellLng - baseCellSize / 2,
                maxLng: cellLng + baseCellSize / 2,
              },
            });
          }
        }
      }
      return cells;
    }

    async function findNearestStreet(lat, lng) {
      try {
        const endpoint = `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?types=address&access_token=${MAPBOX_TOKEN}`;
        const res = await fetch(endpoint);
        const data = await res.json();
        if (data.features && data.features.length > 0) {
          const streetCoord = data.features[0].geometry.coordinates;
          return { lat: streetCoord[1], lng: streetCoord[0], isStreet: true };
        }
        return { lat, lng, isStreet: false };
      } catch (error) {
        console.error("Error finding nearest street:", error);
        return { lat, lng, isStreet: false };
      }
    }

    async function refineLocationWithGeoCells(initialLat, initialLng, exifLat, exifLng, description, city, country) {
      const confidence = description.includes("Low confidence") ? 0.3 : description.includes("Moderate confidence") ? 0.6 : 0.9;
      let bestMatch = { lat: initialLat, lng: initialLng, score: 0, isStreet: false };

      // Prioritize EXIF coordinates if available and valid
      if (exifLat && exifLng && Math.hypot(exifLat - initialLat, exifLng - initialLng) < 0.1) {
        const streetCoord = await findNearestStreet(exifLat, exifLng);
        if (streetCoord.isStreet) {
          bestMatch = { lat: streetCoord.lat, lng: streetCoord.lng, score: 1.0, isStreet: true };
        }
      }

      // Only proceed with GEO cells if no valid EXIF street coordinates
      if (!bestMatch.isStreet) {
        const cells = createGeoCells(initialLat, initialLng, confidence);
        for (const cell of cells) {
          const streetCoord = await findNearestStreet(cell.center.lat, cell.center.lng);
          const geocodedInfo = await reverseGeocode(streetCoord.lat, streetCoord.lng);
          let score = 0;
          if (geocodedInfo.city === city && city !== "unknown") score += 0.5;
          if (geocodedInfo.country === country && country !== "unknown") score += 0.3;
          if (streetCoord.isStreet) score += 0.2;

          // Penalize large deviations
          const distance = Math.hypot(cell.center.lat - initialLat, cell.center.lng - initialLng);
          score -= distance * 0.1; // Reduce score for farther cells

          if (score > bestMatch.score) {
            bestMatch = { lat: streetCoord.lat, lng: streetCoord.lng, score, isStreet: streetCoord.isStreet };
          }
        }
      }

      return bestMatch;
    }

    async function analyzePhotoWithGemini(photoBlob) {
      try {
        const base64Image = await imageToBase64(photoBlob);
        const response = await fetch(
          `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: `Analyze this image with extreme precision to determine its geolocation, ensuring coordinates are on a public street (not inside houses or private properties). Provide the following in JSON format:
                      - latitude (float, precise to 6 decimal places)
                      - longitude (float, precise to 6 decimal places)
                      - city (string, most specific possible)
                      - country (string)
                      - description (string, one-sentence summary of the location, e.g., "On a street near colonial-style houses in Bandung")
                      Perform an in-depth analysis of architectural details (e.g., roof pitch, window styles, cladding materials, ornamentation), environmental context (e.g., tree species, street patterns, weather conditions, utility poles, mailbox styles), and cultural indicators (e.g., road markings, vehicle types, signage fonts). Cross-reference with global architectural and environmental patterns to accurately geolocate generic scenes or house photos without landmarks. If coordinates are uncertain, provide a best estimate based on contextual evidence and note confidence level in the description (e.g., "Low confidence estimate"). Ensure coordinates are on a public street suitable for Street View, validated against road networks. Ensure all fields are filled; use "unknown" if data is unavailable.`
                    },
                    {
                      inlineData: {
                        mimeType: photoBlob.type,
                        data: base64Image,
                      },
                    },
                  ],
                },
              ],
            }),
          }
        );

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.statusText}`);
        }

        const data = await response.json();
        let resultText = data.candidates[0].content.parts[0].text;

        // Clean Markdown code blocks
        resultText = resultText.replace(/```json\n|\n```/g, '').trim();

        // Parse the cleaned JSON
        let locationData;
        try {
          locationData = JSON.parse(resultText);
        } catch (parseError) {
          console.error("Failed to parse Gemini response as JSON:", parseError);
          throw new Error("Invalid JSON response from Gemini API");
        }

        // Validate required fields
        if (!locationData.latitude || !locationData.longitude) {
          throw new Error("Missing latitude or longitude in Gemini response");
        }

        return locationData;
      } catch (error) {
        console.error("Error analyzing photo with Gemini:", error);
        alert("Failed to analyze image with Gemini API. Using default location.");
        return {
          lat: 0,
          lng: 0,
          city: "unknown",
          country: "unknown",
          description: "unknown",
        };
      }
    }

    async function reverseGeocode(lat, lng) {
      try {
        const endpoint = `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?access_token=${MAPBOX_TOKEN}`;
        const res = await fetch(endpoint);
        const data = await res.json();
        let detail = "unknown", country = "unknown", city = "unknown";
        if (data.features && data.features.length > 0) {
          detail = data.features[0].place_name || "unknown";
          data.features.forEach(f => {
            if (f.place_type.includes("country")) country = f.text;
            if (f.place_type.includes("place")) city = f.text;
          });
        }
        return { detail, country, city };
      } catch (error) {
        console.error("Error in reverse geocoding:", error);
        return { detail: "unknown", country: "unknown", city: "unknown" };
      }
    }

    document.getElementById("image-preview").addEventListener("click", () => {
      fileInput.click();
    });

    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      loadingOverlay.style.display = "flex";

      const reader = new FileReader();
      reader.onload = async (evt) => {
        const imageData = evt.target.result;
        previewImg.src = imageData;
        previewImg.style.display = "block";
        uploadOverlay.classList.add("hidden");

        // Enhanced EXIF and Metadata Extraction
        let exifData = { lat: null, lng: null, timestamp: null, device: null, altitude: null };
        EXIF.getData(file, async function() {
          try {
            const gpsLat = EXIF.getTag(this, "GPSLatitude");
            const gpsLng = EXIF.getTag(this, "GPSLongitude");
            const latRef = EXIF.getTag(this, "GPSLatitudeRef") || "N";
            const lngRef = EXIF.getTag(this, "GPSLongitudeRef") || "E";
            exifData.timestamp = EXIF.getTag(this, "DateTimeOriginal") || null;
            exifData.device = EXIF.getTag(this, "Model") || null;
            exifData.altitude = EXIF.getTag(this, "GPSAltitude") || null;

            if (gpsLat && gpsLng) {
              const lat = gpsLat[0] + gpsLat[1]/60 + gpsLat[2]/3600;
              const lng = gpsLng[0] + gpsLng[1]/60 + gpsLng[2]/3600;
              exifData.lat = latRef === "N" ? lat : -lat;
              exifData.lng = lngRef === "E" ? lng : -lng;
            }
          } catch (exifError) {
            console.error("Error parsing EXIF data:", exifError);
          }

          // Fallback metadata analysis
          if (!exifData.lat && !exifData.lng) {
            try {
              const fileCreationDate = file.lastModifiedDate || new Date();
              exifData.timestamp = exifData.timestamp || fileCreationDate.toISOString();
            } catch (metaError) {
              console.error("Error extracting file metadata:", metaError);
            }
          }

          // Analyze with Gemini
          const locationData = await analyzePhotoWithGemini(file);
          // Refine coordinates using GEO cell partitioning
          const refinedCoord = await refineLocationWithGeoCells(
            parseFloat(locationData.latitude),
            parseFloat(locationData.longitude),
            exifData.lat,
            exifData.lng,
            locationData.description,
            locationData.city,
            locationData.country
          );

          // Ensure street coordinates
          const streetCoord = refinedCoord.isStreet
            ? refinedCoord
            : await findNearestStreet(refinedCoord.lat, refinedCoord.lng);

          let info = {
            detail: locationData.description,
            country: locationData.country,
            city: locationData.city,
          };

          // Fallback to reverse geocoding if needed
          if (info.detail === "unknown" || info.country === "unknown" || info.city === "unknown") {
            const geocodedInfo = await reverseGeocode(streetCoord.lat, streetCoord.lng);
            info = {
              detail: info.detail !== "unknown" ? info.detail : geocodedInfo.detail,
              country: info.country !== "unknown" ? info.country : geocodedInfo.country,
              city: info.city !== "unknown" ? info.city : geocodedInfo.city,
            };
            if (geocodedInfo.city !== "unknown" && locationData.city !== geocodedInfo.city) {
              info.detail += " (Coordinates refined to street; verified city: " + geocodedInfo.city + ")";
            }
          }

          lastMatchedCoord = { lat: streetCoord.lat, lng: streetCoord.lng };

          document.getElementById("detail-value").textContent = info.detail;
          document.getElementById("country-value").textContent = info.country;
          document.getElementById("city-value").textContent = info.city;
          document.getElementById("coord-value").textContent =
            streetCoord.lat.toFixed(6) + ", " + streetCoord.lng.toFixed(6);

          if (trackingMarker) trackingMarker.remove();
          const markerEl = document.createElement("img");
          markerEl.src = imageData;
          markerEl.style.width = "60px";
          markerEl.style.height = "60px";
          markerEl.style.borderRadius = "50%";
          markerEl.style.border = "2px solid white";
          trackingMarker = new mapboxgl.Marker(markerEl)
            .setLngLat([streetCoord.lng, streetCoord.lat])
            .addTo(map);
          map.flyTo({
            center: [streetCoord.lng, streetCoord.lat],
            zoom: 15, // Closer zoom for street-level
            essential: true,
          });

          loadingOverlay.style.display = "none";
        });
      };
      reader.readAsDataURL(file);
    });

    document.getElementById("map-btn").addEventListener("click", () => {
      document.getElementById("streetview-container").style.display = "none";
      document.getElementById("map").style.display = "block";
    });

    document.getElementById("share-geospy").addEventListener("click", () => {
      const lat = lastMatchedCoord.lat;
      const lng = lastMatchedCoord.lng;
      const streetViewUrl = `https://www.google.com/maps/embed?pb=!4v0!6m8!1m7!1sCAoSLEFGMVFpcE1pVUlONllYeXpHdXVpUjd4cjlHcWxGQVZ2cnlyT1I5NmFwTE9B!2m2!1d${lat}!2d${lng}!3f0!4f0!5f0.7820865974627469`;
      document.getElementById("streetview").src = streetViewUrl;
      document.getElementById("streetview-container").style.display = "block";
      document.getElementById("map").style.display = "none";
    });

    document.querySelector(".badge-link").addEventListener("click", () => {
      alert("Enterprise link clicked!");
    });
  </script>
</body>
</html>
