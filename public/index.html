<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Photo Tracking</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.9.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.9.0/mapbox-gl.css' rel='stylesheet' />
    <link href='https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css' rel='stylesheet'>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #121212;
        }
        #map {
            width: calc(100% - 44px);
            height: 100vh;
            position: absolute;
            top: 0;
            right: 0;
            z-index: 1;
        }
        .menu-container {
            position: absolute;
            top: 50%;
            left: 0;
            width: 44px;
            transform: translateY(-50%);
            background: linear-gradient(180deg, #1e1e1e, #0a0a0a);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 0;
            z-index: 1000;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.6);
            border-radius: 0 8px 8px 0;
        }
        .menu-item {
            color: #d1d1d1;
            font-size: 1.1rem;
            margin: 10px 0;
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        .menu-item:hover {
            color: #1a73e8;
            background: rgba(255, 255, 255, 0.08);
            transform: scale(1.1);
        }
        .menu-item input { display: none; }
        .settings-icon {
            position: absolute;
            bottom: 20px;
            left: 12px;
            z-index: 1001;
        }
        .spinner {
            animation: spin 0.7s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #result {
            position: absolute;
            bottom: 20px;
            left: 60px;
            right: 20px;
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            color: #d1d1d1;
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.5);
            max-width: 85%;
            z-index: 1000;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(10px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #result.show {
            opacity: 1;
            transform: translateY(0);
        }
        .popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
            padding: 16px;
            border-radius: 12px;
            color: #d1d1d1;
            z-index: 2000;
            display: none;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.7);
            animation: popupFadeIn 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .popup.show {
            display: flex;
        }
        @keyframes popupFadeIn {
            from { opacity: 0; transform: translate(-50%, -55%); scale: 0.95; }
            to { opacity: 1; transform: translate(-50%, -50%); scale: 1; }
        }
        .popup button {
            background: #1a73e8;
            color: #ffffff;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s ease, transform 0.1s ease;
        }
        .popup button:hover {
            background: #1557b0;
            transform: translateY(-1px);
        }
        .settings-popup {
            width: 200px;
            padding: 20px;
        }
        .settings-popup label {
            font-size: 0.85rem;
            margin-bottom: 6px;
            color: #b0b0b0;
        }
        .settings-popup select, .settings-popup input[type="checkbox"] {
            margin-bottom: 12px;
            background: #333;
            color: #d1d1d1;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 6px;
            border-radius: 6px;
            font-size: 0.8rem;
        }
        .settings-popup select {
            width: 100%;
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%23d1d1d1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 12px;
        }
        @media (max-width: 600px) {
            .menu-container {
                width: 40px;
                padding: 6px 0;
            }
            .menu-item {
                font-size: 1rem;
                margin: 8px 0;
                padding: 6px;
            }
            .settings-icon {
                bottom: 15px;
                left: 10px;
            }
            #map {
                width: calc(100% - 40px);
            }
            #result {
                font-size: 0.75rem;
                padding: 6px 10px;
                bottom: 15px;
                left: 50px;
                max-width: 80%;
            }
            .popup {
                width: 90%;
                padding: 14px;
            }
            .settings-popup {
                width: 180px;
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="menu-container">
        <label for="fileInput" class="menu-item" id="uploadIcon">
            <i class="bi bi-plus-circle-fill"></i>
        </label>
        <input type="file" id="fileInput" accept="image/*">
        <div class="menu-item" id="agentIcon">
            <i class="bi bi-cpu"></i>
        </div>
    </div>
    <div class="menu-item settings-icon" id="settingsIcon">
        <i class="bi bi-gear-fill"></i>
    </div>
    <div id="result"></div>
    <div id="map"></div>
    <div id="agentPopup" class="popup">
        <button onclick="setMode('Global')">Global</button>
        <button onclick="setMode('High Accurate')">High Accurate</button>
    </div>
    <div id="settingsPopup" class="popup settings-popup">
        <label for="geminiModel">Model</label>
        <select id="geminiModel">
            <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
            <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
        </select>
        <label for="googleSearchTool">Google Search</label>
        <input type="checkbox" id="googleSearchTool" checked>
        <button onclick="saveSettings()">Save</button>
    </div>

    <script>
        const MAPBOX_TOKEN = 'pk.eyJ1IjoiYXZpb3BvcnRvbGFubyIsImEiOiJja212cmRrd2QwN3dzMnZuMXV2d25xbWsxIn0.x3y36v9arY9wmBOCZlCXUA';
        mapboxgl.accessToken = MAPBOX_TOKEN;
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/dark-v11',
            center: [106.8456, -6.2088],
            zoom: 10,
            interactive: true,
            attributionControl: false
        });

        let markers = [];
        let coordinatesData = [];
        let mode = 'Global';

        function haversineDistance(coord1, coord2) {
            const R = 6371e3;
            const φ1 = coord1.lat * Math.PI / 180;
            const φ2 = coord2.lat * Math.PI / 180;
            const Δφ = (coord2.lat - coord1.lat) * Math.PI / 180;
            const Δλ = (coord2.lon - coord1.lon) * Math.PI / 180;
            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        fetch('/dataset/kordinator.txt')
            .then(response => {
                if (!response.ok) throw new Error('Failed to load kordinator.txt');
                return response.text();
            })
            .then(data => {
                coordinatesData = data.split('\n')
                    .map(line => {
                        const [lat, lon] = line.split(',').map(Number);
                        return { lat, lon };
                    })
                    .filter(coord => !isNaN(coord.lat) && !isNaN(coord.lon));
            })
            .catch(error => {
                console.error('Error loading kordinator.txt:', error);
                document.getElementById('result').innerHTML = 'Error loading coordinate dataset.';
                document.getElementById('result').classList.add('show');
            });

        async function resizeImage(blob) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const MAX_WIDTH = 800;
                    const MAX_HEIGHT = 600;
                    let width = img.width;
                    let height = img.height;
                    if (width > height) {
                        if (width > MAX_WIDTH) {
                            height *= MAX_WIDTH / width;
                            width = MAX_WIDTH;
                        }
                    } else {
                        if (height > MAX_HEIGHT) {
                            width *= MAX_HEIGHT / height;
                            height = MAX_HEIGHT;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    canvas.toBlob(resolve, 'image/jpeg', 0.8);
                    URL.revokeObjectURL(img.src);
                };
                img.onerror = reject;
            });
        }

        async function imageToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function findClosestCoordinate(lat, lon) {
            let closest = null;
            let minDistance = Infinity;
            const CLUSTER_THRESHOLD = 100;

            coordinatesData.forEach(coord => {
                const distance = haversineDistance({ lat, lon }, coord);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = coord;
                }
            });

            if (closest) {
                const nearbyCoords = coordinatesData.filter(coord => 
                    haversineDistance(closest, coord) < CLUSTER_THRESHOLD
                );
                if (nearbyCoords.length > 1) {
                    const avgLat = nearbyCoords.reduce((sum, c) => sum + c.lat, 0) / nearbyCoords.length;
                    const avgLon = nearbyCoords.reduce((sum, c) => sum + c.lon, 0) / nearbyCoords.length;
                    return { lat: avgLat, lon: avgLon };
                }
            }
            return closest;
        }

        document.getElementById('fileInput').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) {
                document.getElementById('result').innerHTML = '';
                document.getElementById('result').classList.remove('show');
                return;
            }

            const uploadIcon = document.getElementById('uploadIcon');
            uploadIcon.innerHTML = '<i class="bi bi-arrow-repeat spinner"></i>';

            try {
                const resizedBlob = await resizeImage(file);
                const base64Image = await imageToBase64(resizedBlob);

                const response = await fetch('/api/gemini', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        imageData: base64Image.split(',')[1],
                        prompt: "Analyze this image to extract geographic coordinates (latitude, longitude) based on visual landmarks, considering image angle, clarity, and identifiable features. Return coordinates in the format: [latitude, longitude]. If no coordinates can be determined or the image quality is poor, return 'No coordinates found' with a reason"
                    })
                });

                uploadIcon.innerHTML = '<i class="bi bi-plus-circle-fill"></i>';

                if (!response.ok) throw new Error(`Gemini API error: ${response.statusText}`);

                const data = await response.json();
                let result = data.result;

                if (!result) {
                    throw new Error('No valid response from Gemini API');
                }

                let lat, lon;
                if (result.includes('No coordinates found')) {
                    document.getElementById('result').innerHTML = result;
                    document.getElementById('result').classList.add('show');
                    return;
                }

                const match = result.match(/\[(-?\d+\.\d+),\s*(-?\d+\.\d+)\]/);
                if (match) {
                    [lat, lon] = [parseFloat(match[1]), parseFloat(match[2])];
                } else {
                    throw new Error('Invalid coordinate format');
                }

                if (mode === 'High Accurate') {
                    const closestCoord = findClosestCoordinate(lat, lon);
                    if (closestCoord) {
                        lat = closestCoord.lat;
                        lon = closestCoord.lon;
                    }
                }

                markers.forEach(marker => marker.remove());
                markers = [];

                const img = new Image(30, 30);
                img.src = base64Image;
                img.onload = () => {
                    const newMarker = new mapboxgl.Marker({
                        element: createCustomMarker(img),
                        draggable: false
                    })
                    .setLngLat([lon, lat])
                    .addTo(map);
                    markers.push(newMarker);

                    map.flyTo({ center: [lon, lat], zoom: 15 });

                    document.getElementById('result').innerHTML = `Location: ${lat.toFixed(6)}, ${lon.toFixed(6)}`;
                    document.getElementById('result').classList.add('show');
                };
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('result').innerHTML = 'Error processing image. Try a clearer image.';
                document.getElementById('result').classList.add('show');
                uploadIcon.innerHTML = '<i class="bi bi-plus-circle-fill"></i>';
            } finally {
                document.getElementById('fileInput').value = '';
            }
        });

        function createCustomMarker(img) {
            const markerElement = document.createElement('div');
            markerElement.style.backgroundSize = 'cover';
            markerElement.style.width = '30px';
            markerElement.style.height = '30px';
            markerElement.style.borderRadius = '50%';
            markerElement.style.border = '2px solid #fff';
            markerElement.style.backgroundImage = `url(${img.src})`;
            return markerElement;
        }

        document.getElementById('agentIcon').addEventListener('click', () => {
            document.getElementById('agentPopup').classList.toggle('show');
            document.getElementById('settingsPopup').classList.remove('show');
        });

        document.getElementById('settingsIcon').addEventListener('click', () => {
            document.getElementById('settingsPopup').classList.toggle('show');
            document.getElementById('agentPopup').classList.remove('show');
        });

        function setMode(selectedMode) {
            mode = selectedMode;
            document.getElementById('agentPopup').classList.remove('show');
        }

        async function saveSettings() {
            const model = document.getElementById('geminiModel').value;
            const googleSearchEnabled = document.getElementById('googleSearchTool').checked;

            try {
                const response = await fetch('/api/update-settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model,
                        tools: googleSearchEnabled ? [{ googleSearch: {} }] : []
                    })
                });

                if (response.ok) {
                    document.getElementById('settingsPopup').classList.remove('show');
                    document.getElementById('result').innerHTML = 'Settings updated.';
                    document.getElementById('result').classList.add('show');
                } else {
                    throw new Error('Failed to update settings');
                }
            } catch (error) {
                console.error('Error updating settings:', error);
                document.getElementById('result').innerHTML = 'Error updating settings.';
                document.getElementById('result').classList.add('show');
            }
        }
    </script>
</body>
</html>
