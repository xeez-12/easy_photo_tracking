<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mapbox Photo Tracking - Mobile</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.9.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.9.0/mapbox-gl.css' rel='stylesheet' />
    <link href='https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css' rel='stylesheet'>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow-x: hidden;
        }
        #map {
            width: calc(100% - 50px);
            height: 100vh;
            position: absolute;
            top: 0;
            right: 0;
            z-index: 1;
        }
        .menu-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 50px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 0;
            z-index: 1000;
            box-shadow: 2px 0 4px rgba(0, 0, 0, 0.3);
        }
        .menu-item {
            color: #ffffff;
            font-size: 1.5rem;
            margin: 10px 0;
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        .menu-item:hover {
            transform: scale(1.2);
        }
        .menu-item input { display: none; }
        .spinner {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #result {
            position: absolute;
            top: 60px;
            left: 60px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            max-width: 90%;
            z-index: 1000;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #result.show {
            opacity: 1;
        }
        .popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 8px;
            color: #ffffff;
            z-index: 2000;
            display: none;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }
        .popup.show {
            display: flex;
        }
        .popup button {
            background: #4285F4;
            color: #ffffff;
            border: none;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .popup button:hover {
            background: #3578e5;
        }
        .popup input {
            background: #333;
            color: #ffffff;
            border: none;
            padding: 8px;
            border-radius: 4px;
        }
        .settings-popup {
            width: 200px;
        }
        .settings-popup label {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }
        .settings-popup select, .settings-popup input[type="checkbox"] {
            margin-bottom: 10px;
        }
        @media (max-width: 600px) {
            .menu-item {
                font-size: 1.2rem;
            }
            #result {
                font-size: 0.8rem;
                padding: 8px;
                top: 50px;
                left: 50px;
            }
            .popup {
                width: 80%;
            }
        }
    </style>
</head>
<body>
    <div class="menu-container">
        <label for="fileInput" class="menu-item" id="uploadIcon">
            <i class="bi bi-plus-circle"></i>
        </label>
        <input type="file" id="fileInput" accept="image/*">
        <div class="menu-item" id="agentIcon">
            <i class="bi bi-robot"></i>
        </div>
        <div class="menu-item" id="settingsIcon">
            <i class="bi bi-gear"></i>
        </div>
    </div>
    <div id="result"></div>
    <div id="map"></div>
    <div id="agentPopup" class="popup">
        <button onclick="setMode('Global')">Global</button>
        <button onclick="setMode('San Francisco')">San Francisco</button>
        <button onclick="showCustomInput()">Custom</button>
        <input type="text" id="customCoords" placeholder="Enter lat,lon" style="display: none;">
        <button id="customSubmit" style="display: none;" onclick="setCustomCoords()">Submit</button>
    </div>
    <div id="settingsPopup" class="popup settings-popup">
        <label for="geminiModel">Gemini Model:</label>
        <select id="geminiModel">
            <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
            <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
        </select>
        <label for="googleSearchTool">Google Search Tool:</label>
        <input type="checkbox" id="googleSearchTool" checked>
        <button onclick="saveSettings()">Save</button>
    </div>

    <script>
        const MAPBOX_TOKEN = 'pk.eyJ1IjoiYXZpb3BvcnRvbGFubyIsImEiOiJja212cmRrd2QwN3dzMnZuMXV2d25xbWsxIn0.x3y36v9arY9wmBOCZlCXUA';
        mapboxgl.accessToken = MAPBOX_TOKEN;
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/dark-v11',
            center: [106.8456, -6.2088],
            zoom: 10,
            interactive: true,
            attributionControl: false
        });

        let markers = [];
        let coordinatesData = [];
        let mode = 'Global';
        let customCoords = null;

        function haversineDistance(coord1, coord2) {
            const R = 6371e3;
            const φ1 = coord1.lat * Math.PI / 180;
            const φ2 = coord2.lat * Math.PI / 180;
            const Δφ = (coord2.lat - coord1.lat) * Math.PI / 180;
            const Δλ = (coord2.lon - coord1.lon) * Math.PI / 180;
            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        fetch('/dataset/kordinator.txt')
            .then(response => {
                if (!response.ok) throw new Error('Failed to load kordinator.txt');
                return response.text();
            })
            .then(data => {
                coordinatesData = data.split('\n')
                    .map(line => {
                        const [lat, lon] = line.split(',').map(Number);
                        return { lat, lon };
                    })
                    .filter(coord => !isNaN(coord.lat) && !isNaN(coord.lon));
            })
            .catch(error => {
                console.error('Error loading kordinator.txt:', error);
                document.getElementById('result').innerHTML = 'Error loading coordinate dataset.';
                document.getElementById('result').classList.add('show');
            });

        async function resizeImage(blob) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const MAX_WIDTH = 800;
                    const MAX_HEIGHT = 600;
                    let width = img.width;
                    let height = img.height;
                    if (width > height) {
                        if (width > MAX_WIDTH) {
                            height *= MAX_WIDTH / width;
                            width = MAX_WIDTH;
                        }
                    } else {
                        if (height > MAX_HEIGHT) {
                            width *= MAX_HEIGHT / height;
                            height = MAX_HEIGHT;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    canvas.toBlob(resolve, 'image/jpeg', 0.8);
                    URL.revokeObjectURL(img.src);
                };
                img.onerror = reject;
            });
        }

        async function imageToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function findClosestCoordinate(lat, lon) {
            let closest = null;
            let minDistance = Infinity;
            const CLUSTER_THRESHOLD = 100;
            const dataset = mode === 'San Francisco' ? coordinatesData.filter(c => 
                c.lat >= 37.7 && c.lat <= 37.8 && c.lon >= -122.5 && c.lon <= -122.3
            ) : mode === 'Custom' && customCoords ? [customCoords] : coordinatesData;

            dataset.forEach(coord => {
                const distance = haversineDistance({ lat, lon }, coord);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = coord;
                }
            });

            if (closest) {
                const nearbyCoords = dataset.filter(coord => 
                    haversineDistance(closest, coord) < CLUSTER_THRESHOLD
                );
                if (nearbyCoords.length > 1) {
                    const avgLat = nearbyCoords.reduce((sum, c) => sum + c.lat, 0) / nearbyCoords.length;
                    const avgLon = nearbyCoords.reduce((sum, c) => sum + c.lon, 0) / nearbyCoords.length;
                    return { lat: avgLat, lon: avgLon };
                }
            }
            return closest;
        }

        document.getElementById('fileInput').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const uploadIcon = document.getElementById('uploadIcon');
            uploadIcon.innerHTML = '<i class="bi bi-arrow-repeat spinner"></i>';

            try {
                const resizedBlob = await resizeImage(file);
                const base64Image = await imageToBase64(resizedBlob);

                const response = await fetch('/api/gemini', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        imageData: base64Image.split(',')[1],
                        prompt: "Analyze this image to extract geographic coordinates (latitude, longitude) based on visual landmarks, considering image angle, clarity, and identifiable features. Return coordinates in the format: [latitude, longitude]. If no coordinates can be determined or the image quality is poor, return 'No coordinates found' with a reason"
                    })
                });

                uploadIcon.innerHTML = '<i class="bi bi-plus-circle"></i>';

                if (!response.ok) throw new Error(`Gemini API error: ${response.statusText}`);

                const data = await response.json();
                let result = data.result;

                if (!result) {
                    throw new Error('No valid response from Gemini API');
                }

                let lat, lon;
                if (result.includes('No coordinates found')) {
                    document.getElementById('result').innerHTML = result;
                    document.getElementById('result').classList.add('show');
                    return;
                }

                const match = result.match(/\[(-?\d+\.\d+),\s*(-?\d+\.\d+)\]/);
                if (match) {
                    [lat, lon] = [parseFloat(match[1]), parseFloat(match[2])];
                } else {
                    throw new Error('Invalid coordinate format');
                }

                if (mode !== 'Global') {
                    const closestCoord = findClosestCoordinate(lat, lon);
                    if (closestCoord) {
                        lat = closestCoord.lat;
                        lon = closestCoord.lon;
                    }
                }

                markers.forEach(marker => marker.remove());
                markers = [];

                const img = new Image(30, 30);
                img.src = base64Image;
                img.onload = () => {
                    const newMarker = new mapboxgl.Marker({
                        element: createCustomMarker(img),
                        draggable: false
                    })
                    .setLngLat([lon, lat])
                    .addTo(map);
                    markers.push(newMarker);

                    map.flyTo({ center: [lon, lat], zoom: 15 });

                    document.getElementById('result').innerHTML = `Location found: ${lat.toFixed(6)}, ${lon.toFixed(6)}`;
                    document.getElementById('result').classList.add('show');
                };
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('result').innerHTML = 'Error processing image. Try a clearer image with visible landmarks.';
                document.getElementById('result').classList.add('show');
                uploadIcon.innerHTML = '<i class="bi bi-plus-circle"></i>';
            } finally {
                document.getElementById('fileInput').value = '';
            }
        });

        function createCustomMarker(img) {
            const markerElement = document.createElement('div');
            markerElement.style.backgroundSize = 'cover';
            markerElement.style.width = '30px';
            markerElement.style.height = '30px';
            markerElement.style.borderRadius = '50%';
            markerElement.style.border = '2px solid #fff';
            markerElement.style.backgroundImage = `url(${img.src})`;
            return markerElement;
        }

        document.getElementById('agentIcon').addEventListener('click', () => {
            document.getElementById('agentPopup').classList.toggle('show');
            document.getElementById('settingsPopup').classList.remove('show');
        });

        document.getElementById('settingsIcon').addEventListener('click', () => {
            document.getElementById('settingsPopup').classList.toggle('show');
            document.getElementById('agentPopup').classList.remove('show');
        });

        function setMode(selectedMode) {
            mode = selectedMode;
            document.getElementById('agentPopup').classList.remove('show');
            document.getElementById('customCoords').style.display = 'none';
            document.getElementById('customSubmit').style.display = 'none';
        }

        function showCustomInput() {
            document.getElementById('customCoords').style.display = 'block';
            document.getElementById('customSubmit').style.display = 'block';
        }

        function setCustomCoords() {
            const input = document.getElementById('customCoords').value;
            const [lat, lon] = input.split(',').map(Number);
            if (!isNaN(lat) && !isNaN(lon)) {
                customCoords = { lat, lon };
                mode = 'Custom';
                document.getElementById('agentPopup').classList.remove('show');
                document.getElementById('customCoords').style.display = 'none';
                document.getElementById('customSubmit').style.display = 'none';
            } else {
                alert('Invalid coordinates. Use format: lat,lon');
            }
        }

        async function saveSettings() {
            const model = document.getElementById('geminiModel').value;
            const googleSearchEnabled = document.getElementById('googleSearchTool').checked;

            try {
                const response = await fetch('/api/update-settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model,
                        tools: googleSearchEnabled ? [{ googleSearch: {} }] : []
                    })
                });

                if (response.ok) {
                    document.getElementById('settingsPopup').classList.remove('show');
                    document.getElementById('result').innerHTML = 'Settings updated successfully.';
                    document.getElementById('result').classList.add('show');
                } else {
                    throw new Error('Failed to update settings');
                }
            } catch (error) {
                console.error('Error updating settings:', error);
                document.getElementById('result').innerHTML = 'Error updating settings.';
                document.getElementById('result').classList.add('show');
            }
        }
    </script>
</body>
</html>
